<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <!-- Viewport ì„¤ì •ì´ ì¤‘ìš”í•©ë‹ˆë‹¤. ëª¨ë°”ì¼ì—ì„œ ë„ˆë¹„ë¥¼ ì˜¬ë°”ë¥´ê²Œ ì¸ì‹í•˜ë„ë¡ í•©ë‹ˆë‹¤. -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ê°€êµ¬ ì´ˆì„± í€´ì¦ˆ</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;700&display=swap');

        /* --- ê¸°ë³¸ ìŠ¤íƒ€ì¼ (ìˆ˜ì •) --- */
        * {
            box-sizing: border-box; 
            /* ëª¨ë°”ì¼ì—ì„œ í„°ì¹˜ í•˜ì´ë¼ì´íŠ¸ ì œê±° (ì„ íƒ ì‚¬í•­ì´ì§€ë§Œ ê¶Œì¥)
              -webkit-tap-highlight-color: transparent; 
            */
        }
        
        html, body {
            height: 100%; /* í™”ë©´ ë†’ì´ë¥¼ 100%ë¡œ ê³ ì • */
            max-height: 100%; /* ìŠ¤í¬ë¡¤ ë°©ì§€ */
            font-family: 'Noto Sans KR', sans-serif;
            background-color: #f5f5f5; 
            color: #333;
            margin: 0;
            overflow: hidden; /* ìŠ¤í¬ë¡¤ ì ˆëŒ€ ë°©ì§€ */
        }

        body {
            display: flex;
            flex-direction: column; 
            justify-content: center; /* ìˆ˜ì§ ì¤‘ì•™ ì •ë ¬ */
            /* [!!!] í•µì‹¬ ìˆ˜ì • ì§€ì 
              ì¢Œìš° íŒ¨ë”©(2px)ì„ ì œê±°í•©ë‹ˆë‹¤. 
              ì´ íŒ¨ë”©ì´ ëª¨ë°”ì¼ iframe í™˜ê²½ì—ì„œ ë„ˆë¹„ ê³„ì‚° ì˜¤ë¥˜ë¥¼ ì¼ìœ¼í‚¬ ê°€ëŠ¥ì„±ì´ ë†’ìŠµë‹ˆë‹¤.
              ìˆ˜ì§ íŒ¨ë”©(5px)ì€ ìœ ì§€í•©ë‹ˆë‹¤.
            */
            padding: 5px 0;
        }

        /* --- ê²Œì„ ì»¨í…Œì´ë„ˆ (ìˆ˜ì •) --- */
        #game-container {
            width: 100%;
            /* max-width: 500px; ì œê±°ë¨ */
            background-color: #ffffff;
            border-radius: 12px; 
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.08); 
            /* ì»¨í…Œì´ë„ˆ ë‚´ë¶€ì˜ ì´ íŒ¨ë”©(ì¢Œìš° 15px)ì´ 
              body íŒ¨ë”© ëŒ€ì‹  ì¢Œìš° ì—¬ë°± ì—­í• ì„ í•˜ê²Œ ë©ë‹ˆë‹¤. 
            */
            padding: 10px 15px; 
            border: 1px solid #ddd;
            display: flex;
            flex-direction: column;
            margin-bottom: 5px; 
        }

        /* --- ìƒíƒœ í‘œì‹œì¤„ (ìˆ˜ì •) --- */
        #status-bar {
            display: flex;
            justify-content: space-between;
            font-size: 0.9rem; 
            font-weight: 700;
            color: #555;
            margin-bottom: 8px; 
        }

        /* --- ì´ˆì„± (ìˆ˜ì •) --- */
        #choseong-display {
            font-size: 2.5rem; 
            font-weight: 700;
            color: #6a1b9a;
            letter-spacing: 10px;
            margin-bottom: 8px; 
            padding: 10px 0; 
            background-color: #f8f9fa;
            border-radius: 8px; 
            text-align: center;
        }

        /* --- íƒ€ì´ë¨¸ --- */
        #timer-bar-container {
            width: 100%;
            height: 6px; 
            background-color: #e9ecef;
            border-radius: 3px;
            overflow: hidden;
        }

        #timer-bar {
            width: 100%;
            height: 100%;
            background-color: #4caf50;
            transition: width 1s linear;
        }

        /* --- íŒíŠ¸ ì˜ì—­ (ìˆ˜ì •) --- */
        #hint-area {
            min-height: 80px; 
            margin-top: 8px; 
            display: flex;
            flex-direction: column; 
            justify-content: center;
            align-items: center;
            border: 2px dashed #ddd;
            border-radius: 8px; 
            padding: 5px; 
            text-align: center;
        }

        .hint-box { font-size: 0.85rem; color: #555; } 
        #image-hint { font-size: 2.5rem; } 
        #image-hint.hidden { display: none; }

        /* --- í”¼ë“œë°± ë©”ì‹œì§€ (ìˆ˜ì •) --- */
        .feedback {
            font-size: 0.9rem; 
            font-weight: 700;
            padding: 5px; 
            display: none; 
            border-radius: 6px; 
            text-align: center;
            width: 100%;
        }
        .feedback.correct { color: #28a745; background-color: #e6f7ec; }
        .feedback.wrong { color: #dc3545; background-color: #fdeeee; }
        .feedback.info { color: #555; background-color: #f0f0f0; }
        
        /* --- ì…ë ¥ ì˜ì—­ (ìˆ˜ì •) --- */
        #input-area {
            margin-top: 8px; 
            display: flex;
            gap: 5px; 
        }

        #answer-input {
            flex-grow: 1;
            padding: 10px; 
            font-size: 1rem; 
            border: 2px solid #ced4da;
            border-radius: 6px; 
            transition: border-color 0.3s;
            text-align: center; 
            font-weight: 700;
            color: #333;
            font-family: 'Noto Sans KR', sans-serif;
            /* ëª¨ë°”ì¼ì—ì„œ í™•ëŒ€ ë°©ì§€ */
            -webkit-appearance: none;
        }
        #answer-input:focus { border-color: #6a1b9a; outline: none; }
        #answer-input[readonly] { caret-color: transparent; }

        #submit-btn {
            padding: 10px 15px; 
            font-size: 1rem; 
            font-weight: 700;
            background-color: #6a1b9a;
            color: white;
            border: none;
            border-radius: 6px; 
            cursor: pointer;
            transition: background-color 0.3s;
            -webkit-appearance: none;
        }
        #submit-btn:hover { background-color: #4a148c; }

        /* --- ê°€ìƒ í‚¤ë³´ë“œ (ìˆ˜ì •) --- */
        #virtual-keyboard {
            width: 100%;
            /* max-width: 500px; ì œê±°ë¨ */
            margin-top: 5px; 
            /*
              í‚¤ë³´ë“œ ë‚´ë¶€ì˜ ì´ íŒ¨ë”©(ì¢Œìš° 5px)ì´ 
              body íŒ¨ë”© ëŒ€ì‹  ì¢Œìš° ì—¬ë°± ì—­í• ì„ í•˜ê²Œ ë©ë‹ˆë‹¤.
            */
            padding: 5px; 
            background-color: #e9ecef;
            border-radius: 8px; 
            flex-shrink: 0; 
        }
        
        .kbd-row {
            display: flex;
            justify-content: center;
            gap: 3px; 
            margin-bottom: 3px; 
        }
        .kbd-row:last-child { margin-bottom: 0; }

        .kbd-key {
            font-family: 'Noto Sans KR', sans-serif;
            font-size: 0.9rem; 
            font-weight: 700;
            background-color: #ffffff;
            color: #333;
            border: none;
            border-radius: 5px; 
            padding: 8px 0; 
            flex-grow: 1; 
            flex-basis: 0;
            min-width: 26px; 
            
            cursor: pointer;
            user-select: none;
            -webkit-user-select: none; 
            
            box-shadow: 0 2px 2px rgba(0, 0, 0, 0.1);
            transition: background-color 0.1s, transform 0.1s;
            -webkit-appearance: none;
        }
        .kbd-key:active { background-color: #ddd; transform: translateY(1px); }
        
        .kbd-key.special {
            flex-grow: 1.5;
            background-color: #adb5bd;
            color: white;
            font-size: 0.7rem; 
        }
        .kbd-key.special:active { background-color: #868e96; }
        .kbd-key.shift-active { background-color: #a5b4fc; color: #1e3a8a; }

        /* --- ê²Œì„ ì¢…ë£Œ ì˜¤ë²„ë ˆì´ --- */
        #game-over-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            justify-content: center;
            align-items: center;
            z-index: 100;
        }

        #game-over-box {
            background-color: white;
            padding: 30px 40px; 
            border-radius: 15px; 
            text-align: center;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.2);
            animation: zoomIn 0.5s ease;
            /* ì¢Œìš° ì˜ë¦¼ ë°©ì§€ë¥¼ ìœ„í•´ ë„ˆë¹„ ì œí•œ */
            width: 90%;
            max-width: 400px;
        }
        #game-over-box h2 { font-size: 2rem; color: #6a1b9a; margin-top: 0; } 
        #game-over-box p { font-size: 1.2rem; margin-bottom: 25px; } 
        #restart-btn {
            padding: 12px 25px; 
            font-size: 1.1rem; 
            font-weight: 700;
            background-color: #28a745;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s;
            -webkit-appearance: none;
        }
        #restart-btn:hover { background-color: #218838; }
        
        @keyframes zoomIn {
            from { transform: scale(0.5); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

    </style>
</head>
<body>

    <!-- ê²Œì„ ì»¨í…ì¸  -->
    <div id="game-container">
        <div id="status-bar">
            <span id="question-counter">ë¬¸ì œ 1 / 10</span>
            <span id="total-score">ì´ ì ìˆ˜: 0 ì </span>
        </div>
        <div id="question-area">
            <div id="choseong-display">ã…Šã„·</div>
            <div id="timer-bar-container">
                <div id="timer-bar"></div>
            </div>
        </div>

        <div id="hint-area">
            <div id="image-hint" class="hint-box hidden"></div>
            <div id="initial-hint-text" class="hint-box">10ì´ˆ í›„ì— ì´ë¯¸ì§€ íŒíŠ¸ê°€ ë‚˜ì˜µë‹ˆë‹¤. (ì´ 20ì´ˆ)</div>
            
            <div id="feedback-correct" class="feedback correct">ì •ë‹µì…ë‹ˆë‹¤! (+0ì )</div>
            <div id="feedback-wrong" class="feedback wrong">í‹€ë ¸ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.</div>
            <div id="feedback-timeout" class="feedback info">ì‹œê°„ ì´ˆê³¼! ì •ë‹µ: </div>
        </div>

        <div id="input-area">
            <input type="text" id="answer-input" placeholder="ì •ë‹µì„ ì…ë ¥í•˜ì„¸ìš”...">
            <button id="submit-btn">í™•ì¸</button>
        </div>
    </div>
    
    <!-- ê°€ìƒ í‚¤ë³´ë“œ HTML -->
    <div id="virtual-keyboard">
        <div class="kbd-row" id="kbd-row-1">
            <button class="kbd-key" data-key="ã…‚" data-shift="ã…ƒ">ã…‚</button>
            <button class="kbd-key" data-key="ã…ˆ" data-shift="ã…‰">ã…ˆ</button>
            <button class="kbd-key" data-key="ã„·" data-shift="ã„¸">ã„·</button>
            <button class="kbd-key" data-key="ã„±" data-shift="ã„²">ã„±</button>
            <button class="kbd-key" data-key="ã……" data-shift="ã…†">ã……</button>
            <button class="kbd-key" data-key="ã…›">ã…›</button>
            <button class="kbd-key" data-key="ã…•">ã…•</button>
            <button class="kbd-key" data-key="ã…‘">ã…‘</button>
            <button class="kbd-key" data-key="ã…" data-shift="ã…’">ã…</button>
            <button class="kbd-key" data-key="ã…”" data-shift="ã…–">ã…”</button>
        </div>
        <div class="kbd-row" id="kbd-row-2">
            <button class="kbd-key" data-key="ã…">ã…</button>
            <button class="kbd-key" data-key="ã„´">ã„´</button>
            <button class="kbd-key" data-key="ã…‡">ã…‡</button>
            <button class="kbd-key" data-key="ã„¹">ã„¹</button>
            <button class="kbd-key" data-key="ã…">ã…</button>
            <button class="kbd-key" data-key="ã…—">ã…—</button>
            <button class="kbd-key" data-key="ã…“">ã…“</button>
            <button class="kbd-key" data-key="ã…">ã…</button>
            <button class="kbd-key" data-key="ã…£">ã…£</button>
        </div>
        <div class="kbd-row" id="kbd-row-3">
            <button class="kbd-key special" data-key="shift">Shift</button>
            <button class="kbd-key" data-key="ã…‹">ã…‹</button>
            <button class="kbd-key" data-key="ã…Œ">ã…Œ</button>
            <button class="kbd-key" data-key="ã…Š">ã…Š</button>
            <button class="kbd-key" data-key="ã…">ã…</button>
            <button class="kbd-key" data-key="ã… ">ã… </button>
            <button class="kbd-key" data-key="ã…œ">ã…œ</button>
            <button class="kbd-key" data-key="ã…¡">ã…¡</button>
        </div>
        <div class="kbd-row" id="kbd-row-4">
            <button class="kbd-key special" data-key="del">ì§€ìš°ê¸°</button>
            <button class="kbd-key special" data-key="enter">í™•ì¸</button>
        </div>
    </div>
    
    <!-- ê²Œì„ ì¢…ë£Œ í™”ë©´ -->
    <div id="game-over-overlay">
        <div id="game-over-box">
            <h2>ê²Œì„ ì¢…ë£Œ!</h2>
            <p id="final-score">ìµœì¢… ì ìˆ˜: 0 ì </p>
            <button id="restart-btn">ë‹¤ì‹œ ì‹œì‘í•˜ê¸°</button>
        </div>
    </div>

    <script>
        // --- 1. ë°ì´í„° ---
        // [ìˆ˜ì •] 'ì¥ë¡±' -> 'ì˜·ì¥' (ã…‡ã…ˆ)ìœ¼ë¡œ ì›ë³µ
        const questionBank = [
            { choseong: 'ã…Šã„·', answer: 'ì¹¨ëŒ€', imageHint: 'ğŸ›ï¸' },
            { choseong: 'ã…‡ã…ˆ', answer: 'ì˜ì', imageHint: 'ğŸª‘' },
            { choseong: 'ã…Šã……', answer: 'ì±…ìƒ', imageHint: 'ğŸ§‘â€ğŸ’»ğŸ“’âœï¸' }, 
            { choseong: 'ã……ã…Œ', answer: 'ì‹íƒ', imageHint: 'ğŸ½ï¸' }, 
            { choseong: 'ã……ã„¹', answer: 'ì„œë', imageHint: 'ğŸ—„ï¸' }, 
            { choseong: 'ã……ã…', answer: 'ì†ŒíŒŒ', imageHint: 'ğŸ›‹ï¸' }, 
            { choseong: 'ã…‡ã…ˆ', answer: 'ì˜·ì¥', imageHint: 'ğŸ‘šğŸ‘•' }, // [ìˆ˜ì •] 'ì¥ë¡±(ã…ˆã„¹)' -> 'ì˜·ì¥(ã…‡ã…ˆ)'
            { choseong: 'ã…Šã„²ã…‡', answer: 'ì±…ê½‚ì´', imageHint: 'ğŸ“šğŸ“šğŸ“š' }, 
            { choseong: 'ã„±ã…‡', answer: 'ê±°ìš¸', imageHint: 'ğŸª' }, 
            { choseong: 'ã…Œã…ˆ', answer: 'íƒì', imageHint: 'â˜•ï¸ğŸµ' }
        ];

        let shuffledQuestions = [];
        let currentQuestionIndex = 0;
        let totalScore = 0;
        let currentPoints = 2;
        let questionTimer;
        let secondsElapsed;

        // --- 2. HTML ìš”ì†Œ ê°€ì ¸ì˜¤ê¸° ---
        const questionCounterEl = document.getElementById('question-counter');
        const totalScoreEl = document.getElementById('total-score');
        const choseongDisplayEl = document.getElementById('choseong-display');
        const timerBarEl = document.getElementById('timer-bar');
        const initialHintTextEl = document.getElementById('initial-hint-text');
        const imageHintEl = document.getElementById('image-hint');
        const answerInputEl = document.getElementById('answer-input');
        const submitBtnEl = document.getElementById('submit-btn');
        
        const feedbackCorrectEl = document.getElementById('feedback-correct');
        const feedbackWrongEl = document.getElementById('feedback-wrong');
        const feedbackTimeoutEl = document.getElementById('feedback-timeout');
        
        const gameOverOverlayEl = document.getElementById('game-over-overlay');
        const finalScoreEl = document.getElementById('final-score');
        const restartBtnEl = document.getElementById('restart-btn');
        
        const virtualKeyboardEl = document.getElementById('virtual-keyboard');

        // --- 3. í•µì‹¬ ê¸°ëŠ¥ í•¨ìˆ˜ ---

        const isTouchDevice = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);

        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
            return array;
        }

        function startGame() {
            totalScore = 0;
            currentQuestionIndex = 0;
            shuffledQuestions = shuffleArray([...questionBank]); 
            totalScoreEl.textContent = `ì´ ì ìˆ˜: 0 ì `;
            gameOverOverlayEl.style.display = 'none';
            displayQuestion();
        }

        function showInHintArea(elementToShow) {
            initialHintTextEl.style.display = 'none';
            imageHintEl.classList.add('hidden');
            feedbackCorrectEl.style.display = 'none';
            feedbackWrongEl.style.display = 'none';
            feedbackTimeoutEl.style.display = 'none';

            if (elementToShow === 'initial') {
                initialHintTextEl.style.display = 'block';
            } else if (elementToShow === 'image') {
                imageHintEl.classList.remove('hidden');
            } else if (elementToShow === 'correct') {
                feedbackCorrectEl.style.display = 'block';
            } else if (elementToShow === 'wrong') {
                feedbackWrongEl.style.display = 'block';
            } else if (elementToShow === 'timeout') {
                feedbackTimeoutEl.style.display = 'block';
            }
        }
        
        function resetHints() {
            showInHintArea('initial');
        }

        function displayQuestion() {
            resetHints(); 

            answerInputEl.value = '';
            answerInputEl.disabled = false;
            submitBtnEl.disabled = false;
            
            if (isTouchDevice) {
                answerInputEl.readOnly = true;
                answerInputEl.style.caretColor = 'transparent';
            } else {
                answerInputEl.readOnly = false;
                answerInputEl.style.caretColor = 'auto';
                answerInputEl.focus();
            }

            if (currentQuestionIndex >= 10) {
                showGameResult();
                return;
            }

            currentPoints = 2;
            secondsElapsed = 0;
            timerBarEl.style.transition = 'none'; 
            timerBarEl.style.width = '100%';
            timerBarEl.style.backgroundColor = '#4caf50'; 
            
            const question = shuffledQuestions[currentQuestionIndex];
            choseongDisplayEl.textContent = question.choseong;
            questionCounterEl.textContent = `ë¬¸ì œ ${currentQuestionIndex + 1} / 10`;

            clearInterval(questionTimer); 
            questionTimer = setInterval(updateTimer, 1000);
            
            setTimeout(() => {
                timerBarEl.style.transition = 'width 1s linear';
            }, 100);
        }

        function updateTimer() {
            secondsElapsed++;
            const totalTime = 20;
            let timeRemainingPercent = 100 - (secondsElapsed / totalTime) * 100;
            timerBarEl.style.width = `${timeRemainingPercent}%`;

            if (secondsElapsed === 10) {
                currentPoints = 1;
                showImageHint();
                timerBarEl.style.backgroundColor = '#ffc107';
            }
            else if (secondsElapsed === 20) {
                currentPoints = 0;
                clearInterval(questionTimer);
                handleTimeout();
            }
        }

        function showImageHint() {
            const question = shuffledQuestions[currentQuestionIndex];
            imageHintEl.textContent = question.imageHint;
            showInHintArea('image'); 
        }

        function handleTimeout() {
            answerInputEl.disabled = true;
            submitBtnEl.disabled = true;
            
            const correctAnswerWord = shuffledQuestions[currentQuestionIndex].answer;
            feedbackTimeoutEl.textContent = `ì‹œê°„ ì´ˆê³¼! ì •ë‹µ: ${correctAnswerWord}`;
            showInHintArea('timeout'); 

            // [ìˆ˜ì •] ì‹œê°„ ì´ˆê³¼ ì‹œ ë‹¤ìŒ ë¬¸ì œë¡œ ë°”ë¡œ ë„˜ì–´ê°€ì§€ ì•Šê³ , 2ì´ˆ í›„ì— ë‹¤ìŒ ë¬¸ì œ í‘œì‹œ
            setTimeout(() => {
                currentQuestionIndex++; // ë‹¤ìŒ ë¬¸ì œë¡œ ì¸ë±ìŠ¤ ì¦ê°€
                displayQuestion(); // ë‹¤ìŒ ë¬¸ì œ í‘œì‹œ
            }, 2000);
        }

        function checkAnswer() {
            const userInput = answerInputEl.value.trim();
            const currentQuestion = shuffledQuestions[currentQuestionIndex];
            const correctAnswer = currentQuestion.answer;
            
            let isAnswerCorrect = false;

            if (!userInput) return; 
            
            // [ìˆ˜ì •] 'ì˜ì'ì™€ 'ì˜·ì¥' ëª¨ë‘ ì •ë‹µìœ¼ë¡œ ì²˜ë¦¬
            // í˜„ì¬ ì´ˆì„±ì´ 'ã…‡ã…ˆ'ì¸ ê²½ìš°
            if (currentQuestion.choseong === 'ã…‡ã…ˆ') {
                // 'ì˜ì' ë˜ëŠ” 'ì˜·ì¥' ë‘˜ ë‹¤ ì •ë‹µìœ¼ë¡œ ì¸ì •
                if (userInput === 'ì˜ì' || userInput === 'ì˜·ì¥') {
                    isAnswerCorrect = true;
                }
            } else {
                // ê·¸ ì™¸ì˜ ê²½ìš°, ì •ë‹µê³¼ ì •í™•íˆ ì¼ì¹˜í•˜ëŠ”ì§€ í™•ì¸
                if (userInput === correctAnswer) {
                    isAnswerCorrect = true;
                }
            }


            if (isAnswerCorrect) {
                clearInterval(questionTimer);
                answerInputEl.disabled = true;
                submitBtnEl.disabled = true;

                totalScore += currentPoints;
                totalScoreEl.textContent = `ì´ ì ìˆ˜: ${totalScore} ì `;
                
                feedbackCorrectEl.textContent = `ì •ë‹µ! +${currentPoints}ì `;
                showInHintArea('correct'); 

                currentQuestionIndex++;
                
                setTimeout(displayQuestion, 1500); 
            }
            else {
                feedbackWrongEl.textContent = 'í‹€ë ¸ìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•˜ì„¸ìš”.';
                showInHintArea('wrong'); 
                
                answerInputEl.value = ''; 
                
                if (!isTouchDevice) {
                    answerInputEl.focus();
                }

                setTimeout(() => {
                    if (secondsElapsed >= 10) {
                        showInHintArea('image');
                    } else {
                        showInHintArea('initial');
                    }
                }, 1000);
            }
        }

        function showGameResult() {
            finalScoreEl.textContent = `ìµœì¢… ì ìˆ˜: ${totalScore} ì `;
            gameOverOverlayEl.style.display = 'flex';

            const scoreMessage = {
                type: 'game_score',
                score: totalScore 
            };
            if (window.parent) {
                window.parent.postMessage(scoreMessage, '*');
            }
        }

        // --- 4. ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
        
        submitBtnEl.addEventListener('click', checkAnswer);
        answerInputEl.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                checkAnswer();
            }
        });
        restartBtnEl.addEventListener('click', startGame);
        
        virtualKeyboardEl.addEventListener('click', function(e) {
            const key = e.target.closest('.kbd-key');
            if (!key) return; 
            if (answerInputEl.disabled) return;

            let keyVal;
            const keyData = key.dataset.key; 
            
            if (keyData === 'shift') {
                toggleShift(); 
                return; 
            } 
            if (keyData === 'del') {
                handleBackspace();
            } else if (keyData === 'enter') {
                checkAnswer();
            } else {
                if (isShifted) {
                    keyVal = key.dataset.shift || key.dataset.key; 
                } else {
                    keyVal = key.dataset.key; 
                }
                typeHangul(keyVal); 
            }
            
            if (!isTouchDevice) {
                answerInputEl.focus();
            }
        });
        
        // --- 5. í•œê¸€ IME (ì¡°í•©/ë¶„í•´) ë¡œì§ ---

        const CHOSEONG = ['ã„±', 'ã„²', 'ã„´', 'ã„·', 'ã„¸', 'ã„¹', 'ã…', 'ã…‚', 'ã…ƒ', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…‰', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
        const JUNGSEONG = ['ã…', 'ã…', 'ã…‘', 'ã…’', 'ã…“', 'ã…”', 'ã…•', 'ã…–', 'ã…—', 'ã…˜', 'ã…™', 'ã…š', 'ã…›', 'ã…œ', 'ã…', 'ã…', 'ã…Ÿ', 'ã… ', 'ã…¡', 'ã…¢', 'ã…£'];
        const JONGSEONG = ['', 'ã„±', 'ã„²', 'ã„³', 'ã„´', 'ã„µ', 'ã„¶', 'ã„·', 'ã„¹', 'ã„º', 'ã„»', 'ã„¼', 'ã„½', 'ã„¾', 'ã„¿', 'ã…€', 'ã…', 'ã…‚', 'ã…„', 'ã……', 'ã…†', 'ã…‡', 'ã…ˆ', 'ã…Š', 'ã…‹', 'ã…Œ', 'ã…', 'ã…'];
        
        const COMPLEX_JAMO_KEY = {
            'ã„±ã……': 'ã„³', 'ã„´ã…ˆ': 'ã„µ', 'ã„´ã…': 'ã„¶', 'ã„¹ã„±': 'ã„º', 'ã„¹ã…': 'ã„»', 'ã„¹ã…‚': 'ã„¼', 'ã„¹ã……': 'ã„½', 'ã„¹ã…Œ': 'ã„¾', 'ã„¹ã…': 'ã„¿', 'ã„¹ã…': 'ã…€', 'ã…‚ã……': 'ã…„',
            'ã…—ã…': 'ã…˜', 'ã…—ã…': 'ã…™', 'ã…—ã…£': 'ã…š', 'ã…œã…“': 'ã…', 'ã…œã…”': 'ã…', 'ã…œã…£': 'ã…Ÿ', 'ã…¡ã…£': 'ã…¢'
        };
        
        const DECOMPOSE_COMPLEX_JAMO = {
            'ã„³': ['ã„±', 'ã……'], 'ã„µ': ['ã„´', 'ã…ˆ'], 'ã„¶': ['ã„´', 'ã…'], 'ã„º': ['ã„¹', 'ã„±'], 'ã„»': ['ã„¹', 'ã…'], 'ã„¼': ['ã„¹', 'ã…‚'], 'ã„½': ['ã„¹', 'ã……'], 'ã„¾': ['ã„¹', 'ã…Œ'], 'ã„¿': ['ã„¹', 'ã…'], 'ã…€': ['ã„¹', 'ã…'], 'ã…„': ['ã…‚', 'ã……'],
            'ã…˜': ['ã…—', 'ã…'], 'ã…™': ['ã…—', 'ã…'], 'ã…š': ['ã…—', 'ã…£'], 'ã…': ['ã…œ', 'ã…“'], 'ã…': ['ã…œ', 'ã…”'], 'ã…Ÿ': ['ã…œ', 'ã…£'], 'ã…¢': ['ã…¡', 'ã…£']
        };

        const HANGUL_START = 0xAC00;
        const HANGUL_END = 0xD7A3;
        
        function compose(choIdx, jungIdx, jongIdx) {
            return String.fromCharCode(HANGUL_START + (choIdx * 21 * 28) + (jungIdx * 28) + jongIdx);
        }

        function decompose(char) {
            const code = char.charCodeAt(0);
            if (code < HANGUL_START || code > HANGUL_END) {
                return null;
            }
            const unicode = code - HANGUL_START;
            const jongIdx = unicode % 28;
            const jungIdx = ((unicode - jongIdx) / 28) % 21;
            const choIdx = Math.floor(((unicode - jongIdx) / 28) / 21);
            return [choIdx, jungIdx, jongIdx];
        }
        
        function typeHangul(key) {
            const val = answerInputEl.value;
            const lastChar = val.slice(-1);
            
            const isJung = JUNGSEONG.includes(key); 
            const isJong = JONGSEONG.includes(key); 

            if (isShifted) {
                toggleShift();
            }

            if (!lastChar || !decompose(lastChar)) {
                if (CHOSEONG.includes(lastChar) && isJung) {
                    const choIdx = CHOSEONG.indexOf(lastChar);
                    const jungIdx = JUNGSEONG.indexOf(key);
                    answerInputEl.value = val.slice(0, -1) + compose(choIdx, jungIdx, 0); 
                }
                else {
                    answerInputEl.value += key;
                }
                return;
            }

            const [choIdx, jungIdx, jongIdx] = decompose(lastChar);

            if (jongIdx === 0) {
                const jung = JUNGSEONG[jungIdx];
                const combinedJung = COMPLEX_JAMO_KEY[jung + key]; 
                
                if (isJung && combinedJung) {
                    const newJungIdx = JUNGSEONG.indexOf(combinedJung);
                    answerInputEl.value = val.slice(0, -1) + compose(choIdx, newJungIdx, 0);
                }
                else if (isJong) {
                    const newJongIdx = JONGSEONG.indexOf(key);
                    if (newJongIdx > 0) { 
                         answerInputEl.value = val.slice(0, -1) + compose(choIdx, jungIdx, newJongIdx);
                    } else {
                         answerInputEl.value += key;
                    }
                }
                else {
                    answerInputEl.value += key;
                }
            }
            else {
                const jong = JONGSEONG[jongIdx];
                const combinedJong = COMPLEX_JAMO_KEY[jong + key]; 

                if (isJung) {
                    let lastCharJong, newCharCho; 
                    const decomposedJong = DECOMPOSE_COMPLEX_JAMO[jong];
                    
                    if (decomposedJong) { 
                        lastCharJong = decomposedJong[0];
                        newCharCho = decomposedJong[1];
                    } else { 
                        lastCharJong = '';
                        newCharCho = jong;
                    }

                    const newLastJongIdx = JONGSEONG.indexOf(lastCharJong);
                    const newCharChoIdx = CHOSEONG.indexOf(newCharCho);
                    const newCharJungIdx = JUNGSEONG.indexOf(key);

                    answerInputEl.value = val.slice(0, -1) + 
                                        compose(choIdx, jungIdx, newLastJongIdx) + 
                                        compose(newCharChoIdx, newCharJungIdx, 0);
                }
                else if (isJong && combinedJong && JONGSEONG.includes(combinedJong)) {
                    const newJongIdx = JONGSEONG.indexOf(combinedJong);
                    answerInputEl.value = val.slice(0, -1) + compose(choIdx, jungIdx, newJongIdx);
                }
                else {
                    answerInputEl.value += key;
                }
            }
        }
        
        function handleBackspace() {
            const val = answerInputEl.value;
            if (val.length === 0) return;

            const lastChar = val.slice(-1);
            const decomposed = decompose(lastChar);
            
            if (!decomposed) {
                answerInputEl.value = val.slice(0, -1);
                return;
            }

            const [choIdx, jungIdx, jongIdx] = decomposed;
            
            if (jongIdx > 0) {
                const jong = JONGSEONG[jongIdx];
                const decomposedJong = DECOMPOSE_COMPLEX_JAMO[jong]; 

                if (decomposedJong) {
                    const newJongIdx = JONGSEONG.indexOf(decomposedJong[0]);
                    answerInputEl.value = val.slice(0, -1) + compose(choIdx, jungIdx, newJongIdx);
                } 
                else {
                    answerInputEl.value = val.slice(0, -1) + compose(choIdx, jungIdx, 0);
                }
            }
            else {
                const jung = JUNGSEONG[jungIdx];
                const decomposedJung = DECOMPOSE_COMPLEX_JAMO[jung]; 

                if (decomposedJung) {
                    const newJungIdx = JUNGSEONG.indexOf(decomposedJung[0]);
                    answerInputEl.value = val.slice(0, -1) + compose(choIdx, newJungIdx, 0);
                }
                else {
                    answerInputEl.value = val.slice(0, -1) + CHOSEONG[choIdx];
                }
            }
        }
        
        let isShifted = false;
        const shiftKeyEl = document.querySelector('.kbd-key[data-key="shift"]');
        const shiftableKeyEls = document.querySelectorAll('.kbd-key[data-shift]');
        
        function toggleShift() {
            isShifted = !isShifted;
            shiftKeyEl.classList.toggle('shift-active', isShifted);
            
            shiftableKeyEls.forEach(keyEl => {
                 const originalKey = keyEl.dataset.key; 
                 const shiftKey = keyEl.dataset.shift; 
                 
                 if (isShifted) {
                     keyEl.textContent = shiftKey; 
                 } else {
                     keyEl.textContent = originalKey; 
                 }
            });
        }

        // --- 6. ê²Œì„ ì‹œì‘ ---
        startGame();

    </script>
</body>
</html>
